# Exercise1
There is no integer overflow consideration, but since it takes 1 Ether to purchase votingRights, the overflow is not nearly reached, so it is not a vulnerability.

```
// line #29
// require(balances[msg.sender]!=0);
require(balances[msg.sender] >= _amount);
```

If you don't make sure that there is no more than the specified _amount in balances, anyone can send more _amounts than the balances you hold.

# Exercise2
```
// line #55
require(_nbVotes + votesCast[msg.sender]<=votingRights[msg.sender]); // Check you have enough voting rights.
uint total = _nbVotes + votesCast[msg.sender];
assert(total >= _nbVotes);
```

If you don't consider integer overflow, anyone can vote for the maximum value of a 256-bit number in one ether.


# Exercise3
```
// line #77
// require(_price * _amount * 1 ether <= msg.value);
uint total = _price * _amount;
assert(total / _price == _amount);
```

Integer overflow needs to be considered.

# Exercise4
```
// line #111
// msg.sender.transfer(safe.amount);
// safe.amount=0;
uint amount = safe.amount
safe.amount = 0;
msg.sender.transfer(amount);
```

Need to prevent re-entrancy attacks.


# Exercise5
```
// line #141
// function recordContribution(address _user, uint _amount)
function recordContribution(address _user, uint _amount) private
```

Need to make function visibility private.
Currently, function visibility is public, so anyone can increase the number of amounts of contributions to any user they want.

# Exercise6
```
// line #172
// balances[_recipient]=+balances[msg.sender];
balances[_recipient]+=balances[msg.sender];
```

`+=`, not `=+`

# Exercise7
```
// line #188
// require(msg.value * (1 + objectBought[msg.sender]) == basePrice);
require(msg.value * (1 + objectBought[msg.sender]) == price());
```

The object price is fixed at basePrice, so it will not be discounted according to the specification.

# Exercise8
```
// line #207
// bool lastChoiceHead;
```

The lastChoiceHead is private in the contract, but the value can be inferred from outside the blockchain.
Therefore, an attacker can know what you have chosen and can receive 2 ether again and again.

# Exercise9
```
// line #249
// msg.sender.call.value(balances[msg.sender])();
// balances[msg.sender]=0;
uint amount = balances[msg.sender];
balances[msg.sender] = 0;
msg.sender.transfer(amount);
```

Need to prevent re-entrancy attacks.

# Exercise10
```
// line #295
// keccak256(_chooseHead, _randomNumber)
```

The value hashed by keccak256 is a combination of bool and uint256, and can be inferred.

# Exercise11
①
```
// line #344
// msg.sender.transfer(coffer.slots[_slot]);
// coffer.slots[_slot] = 0;
uint amount = coffer.slots[_slot];
coffer.slots[_slot] = 0;
msg.sender.transfer(amount);
```

Need to prevent re-entrancy attacks.

②
```
// line #333
// function deposit(uint _coffer, uint _slot) payable external {
function deposit(uint _coffer, uint _slot) payable external {
	require(coffer.owner == msg.sender);
```

If you mistakenly send money to a coffer that you did not create, you will not be able to withdraw it. This is not a problem for "donation" contracts, but it is a vulnerability for "coffer" contracts.
